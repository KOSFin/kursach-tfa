# Отчет по курсовой работе
## Тема: Разработка распознавателя модельного языка программирования (Вариант 18)

### 1. Введение
Целью данной работы является разработка лексического и синтаксического анализатора, а также интерпретатора для модельного языка программирования. Язык поддерживает типизированные переменные, управляющие конструкции (циклы, условия) и базовые операции ввода-вывода.

### 2. Постановка задачи
Необходимо реализовать программное средство, выполняющее следующие функции:
1.  **Лексический анализ**: Разбиение входного текста на токены (лексемы).
2.  **Синтаксический анализ**: Проверка структуры программы и построение абстрактного синтаксического дерева (AST).
3.  **Семантический анализ и интерпретация**: Проверка типов данных и выполнение программы.

**Вариант задания: 18 (Код 231123)**
*   **Типы данных**: Целый (`%`), Действительный (`!`), Логический (`$`).
*   **Комментарии**: Многострочные `(* ... *)`.
*   **Структура программы**: Последовательность операторов и описаний, завершающаяся `end`.
*   **Операторы**: Присваивание (`:=`), Составной (`begin ... end`), Условный (`if ... [else]`), Циклы (`for`, `while`), Ввод/Вывод (`readln`, `writeln`).

### 3. Формальная модель
Язык описывается контекстно-свободной грамматикой.
Пример правил (EBNF):
```
<программа> ::= { <оператор> | <описание> } "end"
<описание> ::= <id> { "," <id> } ":" <тип> ";"
<оператор> ::= <присваивание> | <условие> | <цикл> | ...
<тип> ::= "%" | "!" | "$"
```

### 4. Реализация

#### 4.1 Лексический анализатор (`lexer.py`)
Реализован на основе конечного автомата. Читает входной поток посимвольно и формирует токены.
*   Обрабатывает ключевые слова (`if`, `while`, `end`...).
*   Распознает числа в разных системах счисления (10H, 77O, 101B).
*   Игнорирует комментарии `(* ... *)`.

#### 4.2 Синтаксический анализатор (`parser.py`)
Использует метод рекурсивного спуска.
*   Каждому нетерминалу грамматики соответствует метод класса `Parser`.
*   Строит AST, где узлы — это объекты классов `BinOp`, `If`, `While` и т.д.
*   Обрабатывает приоритет операций (умножение выше сложения).

#### 4.3 Интерпретатор (`interpreter.py`)
Обходит AST (паттерн Visitor) и выполняет узлы.
*   **Семантика**: Перед выполнением операций проверяет типы операндов.
*   **Память**: Использует словарь `GLOBAL_SCOPE` для хранения значений переменных.

### 5. Результаты работы
Программа успешно прошла тестирование на наборе контрольных примеров.

**Пример работы (valid_02_control.txt):**
Вход:
```
limit := 5
for i := 1 to limit step 1
    writeln i
next
```
Выход:
```
1
2
3
4
5
```

**Обработка ошибок:**
*   При лексической ошибке (неверный символ) выдается сообщение с указанием строки и позиции.
*   При синтаксической ошибке (пропущена скобка) выполнение прерывается с описанием ожидаемого токена.
*   При семантической ошибке (несовпадение типов) интерпретатор сообщает о недопустимой операции.

### 6. Заключение
В ходе работы были закреплены знания по теории формальных языков. Разработанный интерпретатор корректно выполняет программы на модельном языке, соответствующем варианту 18.

### 7. Приложение
(См. файлы `lexer.py`, `parser.py`, `interpreter.py`, `main.py`)
