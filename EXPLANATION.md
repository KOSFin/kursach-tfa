# ЧТО ЭТО ЗА ПРОЕКТ И КАК ОН РАБОТАЕТ (Гайд для братишки)

Привет! Если ты читаешь это, значит, тебе нужно сдать курсовую по "Теории формальных языков и трансляции" (или чему-то похожему), и ты вообще не понимаешь, что происходит. Не паникуй. Сейчас разложим всё по полочкам.

## 1. Что такое "Модельный язык"?

Представь, что ты создаешь свой собственный язык программирования. Не такой сложный, как Python или C++, а маленький, учебный. В методичке тебе дали правила:
*   Как объявлять переменные (например, `a : %;` вместо `int a;`).
*   Как писать циклы и условия.
*   Какие значки использовать для плюса, минуса, "и", "или".

Твоя задача — написать программу (на Python), которая **понимает** этот твой выдуманный язык и **выполняет** его. Эта программа называется **Интерпретатор**.

## 2. Из чего состоит этот проект?

Весь процесс "понимания" языка разбит на три этапа. Представь конвейер:

### Этап 1: Лексический анализатор (Lexer)
**Файл:** `lexer.py`
**Задача:** Читать текст по буквам и собирать их в слова (токены).

Представь, что у тебя есть текст: `if (a < 10)`.
Для компьютера это просто набор символов: `i`, `f`, ` `, `(`, `a`...
Лексер бежит по строке и говорит:
1.  О, вижу `if` — это **Ключевое слово**.
2.  Вижу `(` — это **Разделитель**.
3.  Вижу `a` — это **Идентификатор** (имя переменной).
4.  Вижу `<` — это **Операция**.
5.  Вижу `10` — это **Число**.

**Итог:** Лексер превращает кашу из букв в аккуратный список "кирпичиков" (токенов).

### Этап 2: Синтаксический анализатор (Parser)
**Файл:** `parser.py`
**Задача:** Проверить, правильно ли сложены эти "кирпичики", и построить из них структуру (Дерево).

Лексер дал список: `[IF, LPAREN, ID(a), LESS, NUM(10), RPAREN, ...]`.
Парсер смотрит на правила грамматики (из твоего варианта):
*   "Ага, после `if` должна идти скобка". Есть? Есть.
*   "Внутри скобок должно быть выражение". `a < 10` — это выражение? Да.
*   "После скобки должен идти оператор".

Если что-то не так (например, забыл скобку), Парсер орет: "Ошибка синтаксиса!".
Если всё ок, он строит **AST** (Абстрактное Синтаксическое Дерево). Это как схема предложения в русском языке (подлежащее, сказуемое...), только для кода.

### Этап 3: Интерпретатор (Interpreter)
**Файл:** `interpreter.py`
**Задача:** Взять это Дерево и выполнить действия.

Он ходит по дереву:
*   Видит узел "Присваивание": берет значение справа и кладет в переменную слева.
*   Видит узел "Цикл": повторяет действия, пока условие верно.
*   Видит узел "Сложение": складывает два числа.

Тут же происходит **Семантический контроль** (проверка смысла):
*   Нельзя сложить число и слово.
*   Нельзя использовать переменную, которую не объявил.

## 3. Твой вариант (№18)

Твой вариант — это набор конкретных правил. Вот они (код 231123):

1.  **Типы данных:**
    *   `%` — Целое число (как `int`).
    *   `!` — Дробное число (как `float`).
    *   `$` — Логическое (правда/ложь, как `bool`).

2.  **Операции:**
    *   Сравнения: `==`, `!=`, `<`, `>`, `<=`, `>=`.
    *   Логика: `&&` (И), `||` (ИЛИ), `!` (НЕ).
    *   Математика: `+`, `-`, `*`, `/`.

3.  **Структура:**
    *   Программа заканчивается словом `end`.
    *   Переменные объявляются так: `имя : тип;` (например `x : !;`).
    *   Присваивание: `:=`.
    *   Цикл `for`: `for i := 1 to 10 step 1 ... next`.

## 4. Что отвечать преподу?

**В:** Как работает ваш лексический анализатор?
**О:** Он читает файл посимвольно. Если видит цифру — начинает читать число. Если букву — читает слово и проверяет, не ключевое ли оно (типа `if` или `begin`). Пропускает пробелы и комментарии `(* ... *)`.

**В:** Какой метод вы использовали в парсере?
**О:** Метод **рекурсивного спуска**. Это когда для каждого правила грамматики (например, "Оператор", "Выражение") написана своя функция (`statement()`, `expression()`), и они вызывают друг друга.

**В:** Как хранятся переменные?
**О:** В интерпретаторе есть словарь `GLOBAL_SCOPE`, где ключи — это имена переменных, а значения — их текущие значения. И словарь `TYPES` для хранения типов переменных.

**В:** Что будет, если сложить `%` и `!`?
**О:** Мой интерпретатор выдаст ошибку типов, потому что в задании строгая типизация (или выполнит приведение, если ты так решил, но лучше сказать про строгую проверку).

## 5. Как запустить эту шарманку?

1.  Открой терминал (консоль).
2.  Напиши: `python demo.py` (я сделал этот скрипт, он прогонит все тесты).
3.  Или: `python main.py program.txt` (чтобы запустить конкретный файл).

Удачи, братишка! Ты сдашь!
